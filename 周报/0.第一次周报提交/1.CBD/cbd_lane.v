// -----------------------------------------------------------------------------
// Module: cbd_lane
// Description: Implements one parallel lane of the CBD sampler. The lane
//              processes a slice of the random input stream and produces a
//              candidate coefficient. The candidate is generated by computing
//              the difference between the popcount of two eta-wide slices of
//              randomness which realises the centred binomial distribution. A
//              Bernoulli sampler provides a random sign while a rejection filter
//              decides whether the candidate should be accepted. The design is
//              fully pipelined: the computation happens in a combinational stage
//              followed by a register stage for timing closure.
// -----------------------------------------------------------------------------
module cbd_lane #(
    parameter integer ETA            = 3,
    parameter integer LANE_WIDTH     = 32,
    parameter integer CAND_BITS      = 4,
    parameter integer BERN_WIDTH     = 8,
    parameter integer REJ_WIDTH      = 8
) (
    input  wire                     clk,
    input  wire                     reset,
    input  wire                     valid_in,
    input  wire [LANE_WIDTH-1:0]    lane_random,
    input  wire [BERN_WIDTH-1:0]    threshold,
    output reg  [CAND_BITS-1:0]     sample_out,
    output reg                      accept_out,
    output reg                      valid_out
);

    localparam integer COUNT_WIDTH = clog2(ETA + 1);
    localparam integer DIFF_WIDTH  = COUNT_WIDTH + 1;

    // ------------------------------------------------------------------
    // Sanity check for parameter combinations
    // ------------------------------------------------------------------
    initial begin
        if (CAND_BITS < DIFF_WIDTH) begin
            $error("CAND_BITS must be >= DIFF_WIDTH to hold the CBD result");
        end
        if (LANE_WIDTH < (2*ETA + BERN_WIDTH + REJ_WIDTH)) begin
            $error("LANE_WIDTH is insufficient for the configured sub-fields");
        end
    end

    // ------------------------------------------------------------------
    // Extract slices for the CBD, Bernoulli and rejection stages
    // ------------------------------------------------------------------
    wire [ETA-1:0]        a_bits;
    wire [ETA-1:0]        b_bits;
    wire [BERN_WIDTH-1:0] bern_random;
    wire [REJ_WIDTH-1:0]  rej_random;

    assign a_bits       = lane_random[ETA-1:0];
    assign b_bits       = lane_random[(2*ETA)-1:ETA];
    assign bern_random  = lane_random[(2*ETA)+BERN_WIDTH-1:(2*ETA)];
    assign rej_random   = lane_random[(2*ETA)+BERN_WIDTH+REJ_WIDTH-1:(2*ETA)+BERN_WIDTH];

    // ------------------------------------------------------------------
    // Popcount calculations for the two eta-wide slices
    // ------------------------------------------------------------------
    wire [COUNT_WIDTH-1:0] count_a;
    wire [COUNT_WIDTH-1:0] count_b;

    assign count_a = popcount(a_bits);
    assign count_b = popcount(b_bits);

    wire signed [DIFF_WIDTH-1:0] diff_value;
    assign diff_value = $signed({1'b0, count_a}) - $signed({1'b0, count_b});

    // ------------------------------------------------------------------
    // Bernoulli sampling determines the sign of the output
    // ------------------------------------------------------------------
    wire bern_positive;
    bernoulli_sampler #(
        .COMP_WIDTH (BERN_WIDTH)
    ) u_bernoulli (
        .random_value     (bern_random),
        .threshold        (threshold),
        .sign_is_positive (bern_positive)
    );

    wire signed [DIFF_WIDTH-1:0] signed_value;
    assign signed_value = bern_positive ? diff_value : -diff_value;

    wire [DIFF_WIDTH-1:0] magnitude;
    assign magnitude = (signed_value[DIFF_WIDTH-1]) ?
                       (~signed_value + {{(DIFF_WIDTH-1){1'b0}}, 1'b1}) :
                       signed_value;

    // ------------------------------------------------------------------
    // Rejection filter reduces the acceptance probability for samples with
    // large magnitude.
    // ------------------------------------------------------------------
    wire accept_candidate;
    rejection_filter #(
        .VALUE_WIDTH (DIFF_WIDTH),
        .RAND_WIDTH  (REJ_WIDTH)
    ) u_rejection (
        .magnitude     (magnitude),
        .random_value  (rej_random),
        .accept        (accept_candidate)
    );

    // ------------------------------------------------------------------
    // Pipeline registers
    // ------------------------------------------------------------------
    reg signed [DIFF_WIDTH-1:0] signed_value_q;
    reg                        accept_candidate_q;
    reg                        valid_stage1_q;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            signed_value_q     <= {DIFF_WIDTH{1'b0}};
            accept_candidate_q <= 1'b0;
            valid_stage1_q     <= 1'b0;
        end else begin
            valid_stage1_q <= valid_in;
            if (valid_in) begin
                signed_value_q     <= signed_value;
                accept_candidate_q <= accept_candidate;
            end
        end
    end

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            sample_out <= {CAND_BITS{1'b0}};
            accept_out <= 1'b0;
            valid_out  <= 1'b0;
        end else begin
            valid_out <= valid_stage1_q;
            if (valid_stage1_q) begin
                sample_out <= {{(CAND_BITS-DIFF_WIDTH){signed_value_q[DIFF_WIDTH-1]}},
                                signed_value_q};
                accept_out <= accept_candidate_q;
            end
        end
    end

    // ------------------------------------------------------------------
    // Utility functions
    // ------------------------------------------------------------------
    function integer clog2;
        input integer value;
        integer i;
        begin
            clog2 = 0;
            for (i = value - 1; i > 0; i = i >> 1) begin
                clog2 = clog2 + 1;
            end
        end
    endfunction

    function [COUNT_WIDTH-1:0] popcount;
        input [ETA-1:0] bits;
        integer idx;
        begin
            popcount = {COUNT_WIDTH{1'b0}};
            for (idx = 0; idx < ETA; idx = idx + 1) begin
                popcount = popcount + bits[idx];
            end
        end
    endfunction

endmodule
