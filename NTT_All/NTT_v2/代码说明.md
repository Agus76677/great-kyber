# Kyber NTT/INTT 硬件实现说明

本说明文档简要介绍 `5.NTT` 目录下新增的 Verilog 模块、测试流程以及 Python 黄金模型的使用方法。

## 模块概览

### `barrett_reduce.v`
* 实现 Kyber 模数 `q = 3329` 下的 Barrett 模运算。
* 通过常量 `BARRETT_FACTOR = floor((2^26 + q/2) / q)` 将除法转化为移位与乘法，避免硬件除法器。
* 设计为纯组合逻辑，可在单周期内提供 32 位输入的约简结果。

### `ntt_core.v`
* 基于 Radix-2 蝶形结构的前向 NTT 实现。
* 采用流水线设计：
  * **阶段 0**：根据当前层的地址对，从寄存器阵列中读取两个系数并缓存对应的旋转因子。
  * **阶段 1**：完成乘法（调用 `barrett_reduce`）及模加/模减，并写回寄存器。
* Twiddle 因子按层累乘生成，仅需要 8 个阶段常数，降低 ROM 需求。
* 接口遵循 `start/valid_in/ready_in` 手握手方式：
  * `data_in` 以 128 bit 宽度输入，每拍加载 8 个 16 bit 系数，共 32 拍完成 256 个系数的装载。
  * 计算结束后，`data_out` 以同样格式输出 NTT 结果，同时给出 `valid_out`、`done` 信号。

### `intt_core.v`
* 采用 Gentleman–Sande 结构执行逆向 NTT，并在计算结束后对所有系数乘以 `N^{-1} (mod q)`。
* 在流水线中增加额外一级，用于在模加/模减之后完成乘法约简：
  * **阶段 0**：读取数据与旋转因子。
  * **阶段 1**：计算和/差。
  * **阶段 2**：对差值与旋转因子相乘并约简，然后写回。
* 在输出之前进入 `SCALE` 状态，逐个系数乘以 `INV_N = 3316`，保证逆变换恢复原始系数。

## Python 黄金模型

`test/model_ntt.py` 提供以下功能：
* 通过相同的 Radix-2 算法生成 NTT/INTT 结果，作为硬件验证基准。
* 预先生成 4 组随机多项式（256 项，模 3329）及其 NTT、INTT 结果，写入：
  * `input_poly.hex`
  * `ntt_expected.hex`
  * `intt_expected.hex`
* 文件采用 128 bit 每行（8×16 bit）的格式，与硬件接口保持一致。

运行脚本：
```bash
python 5.NTT/test/model_ntt.py
```

## Testbench 与仿真

`test/tb_ntt_intt.v` 负责：
* 读入上述 HEX 文件，驱动 `ntt_core` 与 `intt_core`。
* 对输出结果逐拍比对，发现不一致会直接报错并终止仿真。
* 成功通过所有测试后输出 `NTT/INTT test completed successfully`。

仿真命令：
```bash
iverilog -g2012 -o 5.NTT/test/ntt_intt_tb.vvp \
  5.NTT/barrett_reduce.v 5.NTT/ntt_core.v 5.NTT/intt_core.v \
  5.NTT/test/tb_ntt_intt.v
vvp 5.NTT/test/ntt_intt_tb.vvp
```

## 数据接口约定

* 输入/输出总线均为 128 bit，按低位到高位依次存储 8 个 16 bit 系数。
* `start` 需在装载前拉高一个时钟周期，`ready_in` 高表示可接受新数据。
* `valid_out` 表示 `data_out` 当前拍有效，输出共 32 拍。
* `done` 在最后一个输出拍置高一个周期，便于上层逻辑捕获。

## 资源与延迟说明

* 内部寄存器阵列存储 256 个 16 bit 系数，可映射为 FPGA BRAM/SRAM。
* NTT 计算总计 1024 次蝶形操作，采用 2 级流水线；INTT 含 3 级流水线及额外的缩放阶段。
* Barrett 模运算完全组合化，可在高频工作下提供稳定的模乘结果。

以上内容可帮助您快速集成与验证 Kyber NTT/INTT 硬件模块。
