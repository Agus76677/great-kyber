import math
from pathlib import Path

PRECISION = 16
GAUSS_CDF_WIDTH = PRECISION
MAX_SYMBOLS = 16
TAIL_MAX = 256
SIGMA_VALUES = list(range(1, 9))
DEFAULT_SIGMA = 4


def discrete_gaussian_prob(k: int, sigma: float) -> float:
    return math.exp(-(k * k) / (2.0 * sigma * sigma))


def build_tables():
    tables = {}
    tail_probs = {}
    for sigma in SIGMA_VALUES:
        sigma_f = float(sigma)
        norm = 0.0
        for k in range(-TAIL_MAX, TAIL_MAX + 1):
            norm += discrete_gaussian_prob(k, sigma_f)
        pmf_abs = []
        for k in range(MAX_SYMBOLS):
            if k == 0:
                prob = 1.0 / norm
            else:
                prob = 2.0 * discrete_gaussian_prob(k, sigma_f) / norm
            pmf_abs.append(prob)
        accum = 0.0
        thresholds = []
        prev_scaled = -1
        for prob in pmf_abs:
            accum += prob
            scaled = int(math.floor(accum * (1 << PRECISION)))
            if scaled > (1 << PRECISION) - 1:
                scaled = (1 << PRECISION) - 1
            if scaled <= prev_scaled:
                scaled = prev_scaled + 1
                if scaled > (1 << PRECISION) - 1:
                    scaled = (1 << PRECISION) - 1
            thresholds.append(scaled)
            prev_scaled = scaled
        tail_mass = max(0.0, 1.0 - accum)
        tail_scaled = (1 << PRECISION) - 1 - thresholds[-1]
        tables[sigma] = thresholds
        tail_probs[sigma] = {
            "probability": tail_mass,
            "scaled": max(0, tail_scaled),
        }
    return tables, tail_probs


def emit_verilog_header(tables, tail_probs, path: Path):
    lines = []
    lines.append("// This file is auto-generated. Do not edit manually.\n")
    lines.append("// Generated by generate_cdf_tables.py\n")
    lines.append("\n")
    lines.append("function automatic [GAUSS_CDF_WIDTH*GAUSS_MAX_SYMBOLS-1:0] gauss_cdf_pack;\n")
    lines.append("    input [7:0] sigma;\n")
    lines.append("    begin\n")
    lines.append("        case (sigma)\n")
    for sigma in SIGMA_VALUES:
        thresholds = tables[sigma]
        vec = ", ".join(f"{GAUSS_CDF_WIDTH}'d{value}" for value in thresholds[::-1])
        lines.append(f"            8'd{sigma}: gauss_cdf_pack = {{{vec}}};\n")
    default_vec = ", ".join(
        f"{GAUSS_CDF_WIDTH}'d{value}" for value in tables[DEFAULT_SIGMA][::-1]
    )
    lines.append(f"            default: gauss_cdf_pack = {{{default_vec}}};\n")
    lines.append("        endcase\n")
    lines.append("    end\n")
    lines.append("endfunction\n\n")
    lines.append("function automatic [GAUSS_CDF_WIDTH-1:0] gauss_tail_threshold;\n")
    lines.append("    input [7:0] sigma;\n")
    lines.append("    begin\n")
    lines.append("        case (sigma)\n")
    for sigma in SIGMA_VALUES:
        tail_scaled = tail_probs[sigma]["scaled"]
        lines.append(f"            8'd{sigma}: gauss_tail_threshold = {GAUSS_CDF_WIDTH}'d{tail_scaled};\n")
    default_tail = tail_probs[DEFAULT_SIGMA]["scaled"]
    lines.append(f"            default: gauss_tail_threshold = {GAUSS_CDF_WIDTH}'d{default_tail};\n")
    lines.append("        endcase\n")
    lines.append("    end\n")
    lines.append("endfunction\n")
    path.write_text("".join(lines))



def main():
    tables, tail_probs = build_tables()
    header_path = Path(__file__).resolve().parents[1] / "src" / "gauss_cdf_rom.vh"
    emit_verilog_header(tables, tail_probs, header_path)
    stats_path = Path(__file__).resolve().with_suffix(".json")
    import json

    stats_path.write_text(json.dumps({"tables": tables, "tails": tail_probs}, indent=2))


if __name__ == "__main__":
    main()
